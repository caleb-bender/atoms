using CalebBender.Atoms.DataAttributes;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using CalebBender.Atoms.Exceptions;

namespace CalebBender.Atoms.Repositories.SqlServer.SqlGeneration
{
	internal static class InsertSqlGenerator<TModel>
		where TModel : class, new()
	{
		private static readonly Dictionary<Type, string> identityTypeToStringMapping = new Dictionary<Type, string>
		{
			[typeof(byte)] = "TINYINT",
			[typeof(short)] = "SMALLINT",
			[typeof(int)] = "INT",
			[typeof(long)] = "BIGINT"
		};
		private static readonly string insertIntoText = GetInsertIntoText();

		internal static (string, IEnumerable<SqlParameter>) GetInsertSqlTextAndParameters(IEnumerable<TModel> models)
		{
			if (ThereAreNoWritableProperties())
				throw new NoWritableModelPropertiesExistException("There does not exist at least one model property that can be written to the database. Does your model have at least one property that is not an autogenerated unique id nor ignored?");
			List<List<SqlParameter>> modelsParameters = new List<List<SqlParameter>>();
			for (int index = 0; index < models.Count(); index++)
			{
				modelsParameters.Add(new List<SqlParameter>());
				var model = models.ElementAt(index);
				if (model is null) throw new ArgumentNullException("A model passed to CreateManyAsync cannot be null.");
				var modelParameters = GetAllParametersForModel(index, model);
				modelsParameters.ElementAt(index).AddRange(modelParameters);
			}
			var valuesText = $"VALUES " + GetValuesTuplesToInsert(modelsParameters) + "; ";
			var insertSqlText = insertIntoText + valuesText + GetSelectFromOutputTableSqlText();
			return (insertSqlText, modelsParameters.SelectMany(selected => selected));
		}

		private static IEnumerable<SqlParameter> GetAllParametersForModel(int index, TModel? model)
		{
			var modelParameters = new List<SqlParameter>();
			foreach (var modelProperty in ModelMetadata<TModel>.PublicProperties)
			{
				if (
					PropertyIsAutoGeneratedUniqueId(modelProperty)
					|| PropertyShouldBeIgnoredOnCreation(modelProperty)
				) continue;
				var databasePropertyName = PropertyMappingUtilities<TModel>.GetDbPropertyNameOfModelProperty(modelProperty);
				var modelPropertyValue = PropertyMappingUtilities<TModel>.GetModelPropertyDatabaseValue(modelProperty, model);
				modelParameters.Add(new SqlParameter("@" + databasePropertyName + index.ToString(), modelPropertyValue ?? DBNull.Value));
			}
			return modelParameters;
		}

		private static string GetValuesTuplesToInsert(IEnumerable<IEnumerable<SqlParameter>> modelsParameters)
		{
			var valuesTuples = "";
			for (int i = 0; i < modelsParameters.Count(); i++)
			{
				var modelParameters = modelsParameters.ElementAt(i);
				valuesTuples += GetValueTupleString(modelParameters);
				if (i + 1 < modelsParameters.Count())
					valuesTuples += ",";
			}
			return valuesTuples;
		}

		private static string GetValueTupleString(IEnumerable<SqlParameter> modelParameters)
		{
			var valueTuple = "(";
			for (int j = 0; j < modelParameters.Count(); j++)
			{
				var modelParameter = modelParameters.ElementAt(j);
				valueTuple += modelParameter.ParameterName;
				if (j + 1 < modelParameters.Count())
					valueTuple += ",";
			}
			valueTuple += ")";
			return valueTuple;
		}

		internal static object GetConvertedIdentityType(object identityValue)
		{
			var identityModelProperty = ModelMetadata<TModel>.FirstAutoGeneratedUniqueIdProperty;
			if (identityModelProperty is null) return 0;
			if (identityModelProperty.PropertyType == typeof(long))
				identityValue = Convert.ToInt64(identityValue);
			else if (identityModelProperty.PropertyType == typeof(int))
				identityValue = Convert.ToInt32(identityValue);
			else if (identityModelProperty.PropertyType == typeof(short))
				identityValue = Convert.ToInt16(identityValue);
			else if (identityModelProperty.PropertyType == typeof(byte))
				identityValue = Convert.ToByte(identityValue);
			return identityValue;
		}

		private static string GetInsertIntoText()
		{
			var insertIntoText = GetDeclareTemporaryOutputTableSqlText();
			insertIntoText += $"INSERT INTO [{ModelMetadata<TModel>.TableName}](";
			int i = 0;
			foreach (var modelProperty in ModelMetadata<TModel>.PublicProperties)
			{
				if (
					PropertyIsAutoGeneratedUniqueId(modelProperty)
					|| PropertyShouldBeIgnoredOnCreation(modelProperty)
				) continue;
				var databasePropertyName = PropertyMappingUtilities<TModel>.GetDbPropertyNameOfModelProperty(modelProperty);
				insertIntoText += $"[{databasePropertyName}]";
				if (++i < ModelMetadata<TModel>.PublicProperties.Count())
					insertIntoText += ", ";
			}
			insertIntoText += ") ";
			insertIntoText = insertIntoText.Replace(", )", ")");
			return insertIntoText + GetOutputIntoTemporaryTableClause();
		}

		private static string GetDeclareTemporaryOutputTableSqlText()
		{
			var identity = ModelMetadata<TModel>.FirstAutoGeneratedUniqueIdProperty;
			if (identity is null) return "";
			return $"DECLARE @OutputTable TABLE (Id {identityTypeToStringMapping[identity.PropertyType]}); ";
		}

		private static string GetOutputIntoTemporaryTableClause()
		{
			var identity = ModelMetadata<TModel>.FirstAutoGeneratedUniqueIdProperty;
			if (identity is null) return "";
			var identityDatabaseName = ModelMetadata<TModel>.GetDatabasePropertyName(identity);
			return $"OUTPUT INSERTED.[{identityDatabaseName}] INTO @OutputTable ";
		}

		private static string GetSelectFromOutputTableSqlText()
		{
			var identity = ModelMetadata<TModel>.FirstAutoGeneratedUniqueIdProperty;
			if (identity is null) return "";
			return "SELECT Id FROM @OutputTable;";
		}

		internal static bool PropertyIsAutoGeneratedUniqueId(PropertyInfo modelProperty)
		{
			return modelProperty.GetCustomAttribute<UniqueIdAttribute>() is UniqueIdAttribute uniqueIdAttribute && uniqueIdAttribute.AutoGenerated;
		}

		private static bool PropertyShouldBeIgnoredOnCreation(PropertyInfo modelProperty)
		{
			return modelProperty.GetCustomAttribute<AtomsIgnoreAttribute>() is AtomsIgnoreAttribute attr
				&& attr.OnlyAllowWriteOnCreation == false;
		}

		private static bool ThereAreNoWritableProperties()
		{
			return insertIntoText.Contains($"INSERT INTO [{ModelMetadata<TModel>.TableName}]()");
		}
	}
}
