using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using CalebBender.Atoms.DataAttributes;
using CalebBender.Atoms.Exceptions;
using CalebBender.Atoms.Repositories.SqlServer;

namespace CalebBender.Atoms.Repositories.SqlServer.SqlGeneration
{
	internal static class UpdateSqlGenerator<TModel> where TModel : class, new()
	{
		private static readonly Type modelType = typeof(TModel);

		internal static (string, IEnumerable<SqlParameter>) GetUpdateSqlTextAndParameters(
			IEnumerable<TModel> models, string? entityName)
		{
			string updateSqlText = "";
			var updateParameters = new List<SqlParameter>();
			int modelNumber = 0;
			foreach ( var model in models )
			{
				if (model is null) throw new ArgumentNullException("A model passed to UpdateManyAsync cannot be null.");
				var (singleModelUpdateSqlText, singleModelUpdateParameters) =
					GetUpdateTextAndParametersForSingleModel(modelNumber++, model, entityName);
				updateSqlText += singleModelUpdateSqlText;
				updateParameters.AddRange(singleModelUpdateParameters);
			}
			return (updateSqlText, updateParameters);
		}

		private static (string, IEnumerable<SqlParameter>) GetUpdateTextAndParametersForSingleModel(int modelNumber, TModel model, string? entityName)
		{
			var singleModelUpdateParameters = new List<SqlParameter>();
			string singleModelUpdateSqlText = $"UPDATE [{entityName ?? ModelMetadata<TModel>.TableName}] SET ";
			var numberOfPublicProperties = ModelMetadata<TModel>.PublicProperties.Count();
            for (int propertyIndex = 0; propertyIndex < numberOfPublicProperties; propertyIndex++)
			{
				var property = ModelMetadata<TModel>.PublicProperties.ElementAt(propertyIndex);
				if (property.GetCustomAttribute<AtomsIgnoreAttribute>() is not null) continue;
                var (modelParameter, setText) = GetModelParameterAndSetText(propertyIndex, modelNumber, model);
				singleModelUpdateSqlText += setText;
				singleModelUpdateParameters.Add(modelParameter);
			}
			var singleModelUpdateSqlTextWithWhereClause = GetWithWhereClause(singleModelUpdateSqlText, modelNumber);
			return (singleModelUpdateSqlTextWithWhereClause, singleModelUpdateParameters);
		}

		private static string GetWithWhereClause(string singleModelUpdateSqlText, int modelNumber)
		{
			var singleModelUpdateSqlTextWithWhereClause = singleModelUpdateSqlText + GetWhereClauseText(modelNumber) + "; ";
			if (ThereAreNoWritableProperties(singleModelUpdateSqlTextWithWhereClause))
				throw new NoWritableModelPropertiesExistException("There does not exist at least one model property that can be written to the database. Does your model have at least one property that is not an autogenerated unique id nor ignored?");
			return singleModelUpdateSqlTextWithWhereClause.Replace(",  WHERE", " WHERE");
		}

		private static (SqlParameter, string) GetModelParameterAndSetText(int propertyIndex, int modelNumber, TModel model)
		{
			var property = ModelMetadata<TModel>.PublicProperties.ElementAt(propertyIndex);
			var propertyName = ModelMetadata<TModel>.GetDatabasePropertyName(property);
			var setText = GetSetTextForParameter(modelNumber, property, propertyName);
			var propertyValue = PropertyMappingUtilities<TModel>.GetModelPropertyDatabaseValue(property, model);
			var modelParameter = new SqlParameter("@" + propertyName + modelNumber, propertyValue ?? DBNull.Value);
			return (modelParameter, setText);
		}

		private static string GetSetTextForParameter(int modelNumber, PropertyInfo property, string propertyName)
		{
			bool parameterShouldBeAdded = !InsertSqlGenerator<TModel>.PropertyIsAutoGeneratedUniqueId(property)
							&& !ShouldBeIgnored(property);
			if (parameterShouldBeAdded)
				return "[" + propertyName + "]" + " = @" + propertyName + modelNumber + ", ";
			return "";
		}

		private static bool ShouldBeIgnored(PropertyInfo property)
		{
			return property.GetCustomAttribute<AtomsIgnoreAttribute>() is AtomsIgnoreAttribute attr;
		}

		internal static string GetWhereClauseText(int modelNumber)
		{
			var whereClause = " WHERE ";
			for (int i = 0; i < ModelMetadata<TModel>.UniqueIdPublicProperties.Count(); i++)
			{
				var property = ModelMetadata<TModel>.UniqueIdPublicProperties.ElementAt(i);
				string propertyName = ModelMetadata<TModel>.GetDatabasePropertyName(property);
				whereClause += $"[{propertyName}] = @{propertyName}{modelNumber}";
				if (i != ModelMetadata<TModel>.UniqueIdPublicProperties.Count() - 1)
					whereClause += " AND ";
			}
			return whereClause;
		}

		private static bool ThereAreNoWritableProperties(string singleUpdateText)
		{
			return singleUpdateText.Contains("SET  WHERE");
		}
	}
}
