
# Atoms Data Model Classes (2.0.x)
## Introduction
In Atoms, data model classes (also commonly known as Data Transfer Objects or DTOs) are the foundational building blocks that make the Atoms ORM so powerful. For instance, one of the core interfaces you will utilize is the `IAtomicRepository<TModel>`. As of version 2.0.x, the interface definition is below:
```csharp
namespace CalebBender.Atoms.Repositories
{
	public interface IAtomicRepository<TModel> where TModel : class, new()
	{
		Task<IEnumerable<TModel>> CreateManyAsync(IEnumerable<TModel> models);
		Task<AtomicOption<TModel>> GetOneAsync(TModel model);
		Task<int> UpdateManyAsync(IEnumerable<TModel> models);
		Task<int> DeleteManyAsync(IEnumerable<TModel> models);
	}
}
```
Each of these methods allow you to plug in any instance or set of instances of a data class model of type `TModel` and perform CRUD operations that are atomic; that is, they either fully succeed or not at all. However, before you can use a data class within a `IAtomicRepository<TModel>` instance, you must add an attribute to it.
## Setting up the data model class for an IAtomicRepository
Suppose you have the following SQL Server table definition:
```sql
CREATE TABLE BlogPostAuthors(
	AuthorId BIGINT PRIMARY KEY,
	AuthorName NVARCHAR(100) NOT NULL,
	UserRegisteredOn DATE NOT NULL
);
```
And a corresponding data model class:
```csharp
public class BlogPostAuthor
{
	public long AuthorId { get; set; }
	public string AuthorName { get; set; }
	public DateTime UserRegisteredOn { get; set; }
}
```
In order to use this class with an `IAtomicRepository<TModel>` implementation, you must annotate the public property or properties used as a unique identifier in the database. In this case, our SQL Server table only uses a single column, `AuthorId`, for the primary key, so the revised class definition would look like this:
```csharp
using CalebBender.Atoms.DataAttributes;

public class BlogPostAuthor
{
	[UniqueId]
	public long AuthorId { get; set; }
	public string AuthorName { get; set; }
	public DateTime UserRegisteredOn { get; set; }
}
``` 
And voila! Your class is now able to be used by an `IAtomicRepository<TModel>` implementation! No extra boilerplate nor bloat, the only requirement is to annotate the public property or properties that are used as unique ids in the database with the `UniqueIdAttribute`. Note that if your database entity (in SQL Server it would be a table) does not contain a unique identifier of any kind, you can still use its corresponding data model class by annotating an arbitrary property. For example, suppose this had been our `BlogPostAuthors` table definition:
```sql
CREATE TABLE BlogPostAuthors(
	AuthorName NVARCHAR(100) NOT NULL,
	UserRegisteredOn DATE NOT NULL
);
```
Then the following data model class would still be compatible with the `IAtomicRepository`:
```csharp
using CalebBender.Atoms.DataAttributes;

public class BlogPostAuthor
{
	[UniqueId]
	public string AuthorName { get; set; }
	public DateTime UserRegisteredOn { get; set; }
}
```
However, since the `AuthorName` property may or may not be unique, the default behavior when retrieving it would be that Atoms will find the very first result from the database. If two rows in that table contained `"John Doe"` for the `AuthorName`, then the first one would be returned when calling `GetOneAsync`. So, while it goes against best practice to use a data model class without an actual unique id, it is entirely possible. Atoms only validates that the `UniqueIdAttribute` is present on at least one of its public properties. Also, Atoms only uses the public properties of the model for mapping to the corresponding database entity. Any internal, protected, or private properties are ignored.

As a note, the current property types that are compatible with the `UniqueIdAttribute` are all primitives, all enum types, and `string, DateTime, or Guid`. 
## Multiple properties used as unique identifier
Suppose you have the following SQL Server table definition:
```sql
CREATE TABLE Employees(
	EmployeeId UNIQUEIDENTIFIER NOT NULL,
	LocationId BIGINT NOT NULL IDENTITY,
	Salary DECIMAL(12,2) NOT NULL,
	CONSTRAINT PK_Employees PRIMARY KEY (EmployeeId, LocationId)
);
```
The corresponding data model class would be the following:
```csharp
using CalebBender.Atoms.DataAttributes;

public class Employee
{
	[UniqueId]
	public Guid EmployeeId { get; set; }
	[UniqueId(AutoGenerated = true)]
	public long LocationId { get; set; }
	public decimal Salary { get; set; }
}
```
Notice that in addition to both the `EmployeeId` and `LocationId` properties being annotated with the `UniqueIdAttribute`, `LocationId`'s attribute contains the constructor property assignment `AutoGenerated = true`. The `AutoGenerated` property defaults to false in the `UniqueIdAttribute`, which means the value of the data model class property is used on writes. Conversely, when the `AutoGenerated` property is set to true, the database is responsible for generating it. Since our `LocationId` column in the `Employees` table is an `IDENTITY` column, it is necessary to mark the model property as auto-generated. Without doing so, Atoms will include the `LocationId` property on writes, which will trigger SQL Server to raise an error, since identity columns are maintained solely by the database engine.
## Resolving differing names between database entity and data class
Suppose you have a table whose name or column names differ from your data model class:
```sql
CREATE TABLE TheBlogUsers(
	UserId BIGINT,
	GroupName NVARCHAR(50),
	CONSTRAINT PK_TheBlogUsers PRIMARY KEY(UserId, GroupName)
);
```
In this case, you can annotate the data class with the `DbEntityNameAttribute` and any necessary public properties with `DbPropertyNameAttribute` like so:
```csharp
using CalebBender.Atoms.DataAttributes;

[DbEntityName("TheBlogUsers")]
public class BlogUser
{
	[UniqueId]
	public long UserId { get; set; }
	[UniqueId]
	[DbPropertyName("GroupId")]
	public string GroupName { get; set; }
}
```
In this example, the `DbEntityNameAttribute` directly above the `BlogUser` class tells Atoms to use the table `TheBlogUsers` when referring to the database entity. In addition, the `GroupName` property will map to the column `GroupId` given its `DbPropertyNameAttribute`. These two attributes allow you to have data classes with different names or naming conventions from your database. Also, Atoms by default appends 's' to the end of the data class name to get the database entity name. Recall from earlier that the table `Employees` can be used with the class `Employee` because of this rule. However, suppose you had a table named `CustomerAddresses` and a data class named `CustomerAddress`. In this case, the `CustomerAddress` class requires the annotation `[DbEntityName("CustomerAddresses")]` since `CustomerAddress` would be converted to `CustomerAddresss` because Atoms will only append an 's' to pluralize the data class name by default.
## Ignoring certain data class public properties
Suppose you want to ignore one or more public properties so that Atoms does not map them when performing CRUD operations. This is very easy to do by utilizing the `AtomsIgnoreAttribute`. Consider the following SQL Server table:
```sql
CREATE TABLE ModelsWithIgnored(
	Id BIGINT PRIMARY KEY,
	PropertyReadFromButNotWrittenTo VARCHAR(50) DEFAULT 'DEFAULT',
	PropertyWrittenAtCreationAndReadOnlyThereafter VARCHAR(50) NULL
);
```
And the corresponding data model class:
```csharp
using CalebBender.Atoms.DataAttributes;

[DbEntityName("ModelsWithIgnored")]
	public class ModelWithIgnored
	{
		[UniqueId]
		public long Id { get; set; }
		[AtomsIgnore]
		public string PropertyNeitherReadFromNorWrittenTo { get; set; }
		[AtomsIgnore(ReadFromDatabase = true)]
		public string PropertyReadFromButNotWrittenTo { get; set; }
		[AtomsIgnore(ReadFromDatabase = true, OnlyAllowWriteOnCreation = true)]
		public string? PropertyWrittenAtCreationAndReadOnlyThereafter { get; set; } = "default";
	}
```
Presently, there are three different ways to use the `AtomsIgnoreAttribute`:
* The first way is to make a public property completely invisible to Atoms. In this example `PropertyNeitherReadFromNorWrittenTo` is completely ignored by Atoms. When doing any CRUD operation, `PropertyNeitherReadFromNorWrittenTo` will remain untouched and it will never be included in a write.
* The second way is to make a public property read-only. This is useful if you had some column that defaults to some value in the database, and you don't want to be able to change it in the future. In this example, `PropertyReadFromButNotWrittenTo` will always be read as `"DEFAULT`" and Atoms will never allow writes to the table column, ignoring any changes made to the data class instance.
* The third and final way is to make the public property read-only and only allow writes on initialization. In this example, `PropertyWrittenAtCreationAndReadOnlyThereafter` is only written to once on creation and is read-only thereafter. If you need to be able to initialize the property, setting `ReadFromDatabase` to true is not sufficient, as you need to also set `OnlyAllowWriteOnCreation` to true so that it can be initialized. Simply put, the second way is useful when the database initializes the value of the read-only property, but the third way comes in handy when you need to initialize the value of the read-only property.

In short, to completely ignore a public property, annotate with `[AtomsIgnore]`. To make a public property purely read-only, annotate with `[AtomsIgnore(ReadFromDatabase = true)]`. Finally, to make a public property read-only after it is initialized by the program, then annotate with `[AtomsIgnore(ReadFromDatabase = true, OnlyAllowWriteOnCreation = true)]`.

As a side note, if you want to create a data model class with a subset of properties from its corresponding database entity, this is completely doable. Atoms only ever reads from/writes to using the public properties defined on the data model class. Consider this example:
```sql
CREATE TABLE Products(
	ProductId UNIQUEIDENTIFIER PRIMARY KEY,
	ProductName NVARCHAR(50) NOT NULL,
	SecretProperty VARCHAR(50) NULL
)
```
You could have the following model, which would not account for the `SecretProperty` column:
```csharp
using CalebBender.Atoms.DataAttributes;

public class Product
{
	[UniqueId]
	public Guid ProductId { get; set; }
	public string ProductName { get; set; }
	// No property for SecretProperty column
}
```
Simply put, the `AtomsIgnoreAttribute` is most useful when you want to stop data from your class from writing to your database, not the other way around.
## Using public properties with complex object types
Let's say you have a data class `BlogPost` that contains the property `BlogComments`, which stores a list of the comments on a particular blog post:
```csharp
using CalebBender.Atoms.DataAttributes;

public class BlogPost
{
	[UniqueId]
	public long PostId { get; set; }
	public string Title { get; set; } = "";
	public string Content { get; set; } = "";
	public List<BlogComment>? BlogComments { get; set; }
}
```
For SQL Server, the corresponding table definition would be the following:
```sql
CREATE TABLE BlogPosts(
	PostId BIGINT PRIMARY KEY,
	Title NVARCHAR(250),
	Content NVARCHAR(4096),
	BlogComments NVARCHAR(MAX) NULL
)
```
Leveraging Newtonsoft.Json, when Atoms comes across a public property of a data class that does not map to a database type it will automatically serialize it into a JSON string on writes and deserialize it into the class property type on reads. Notice that the `BlogComments` column is an `NVARCHAR` with the maximum number of characters, which allows up to 2 GB of data to be stored. This is the recommended approach for SQL Server, since it will make string truncations virtually impossible. In summary, on writes `BlogComments` is automatically serialized to a JSON string and on reads it is automatically deserialized into the class property of type `List<BlogComment>?`.

Please note that the above example may not actually be optimal for production. If there are thousands upon thousands of blog comments, then there would be lots of performance overhead from the serializing/deserializing. Take advantage of this feature when it makes sense to, or when the data being serialized/deserialized is rather small.
## Using Enum properties
I happen to love enumerations. When a property represents a particular category of a finite set of categories, it makes sense to use an enum to improve code clarity. Therefore, Atoms works very flexibly with enumerations. Suppose we were building a hypothetical blog where contributors can publish short stories. Subsequently, we may decide to add a `Genre` enum property to our `BlogPost` data class:
```csharp
public class BlogPost
{
	public enum BlogPostGenre
	{
		Horror,
		Thriller,
		Scifi,
		Fantasy
	}
	[UniqueId]
	public long PostId { get; set; }
	public BlogPostGenre Genre { get; set; }
	public string Title { get; set; } = "";
	public string Content { get; set; } = "";
	public List<BlogComment>? BlogComments { get; set; }
}
```
Atoms converts enum properties to strings on writes and from strings on reads, so in SQL Server, the `Genre` column should be defined as either a `VARCHAR` or an `NVARCHAR` with enough characters to house the enum variant with the longest number of characters. As an example, if the `Genre` property value was equal to `BlogPostGenre.Horror`, then the string `"Horror"` would be saved to the database. 

As a side note, if a string cannot be mapped to an enum variant, an `EnumPropertyMappingFailedException` will be thrown. So if you had a row where the `Genre` column was set to the string `"Drama"`, this exception would be thrown since there is no `BlogPostGenre.Drama` variant. Also, if the `Genre` column was `NULL`, then it would default to the first enum variant, `BlogPostGenre.Horror`.
## String to Enum mapping rules
Sometimes, life isn't so pretty. Let's say you have a SQL Server database with the following table:
```sql
CREATE TABLE CustomerOrders(
	OrderId UNIQUEIDENTIFIER PRIMARY KEY,
	OrderType VARCHAR(10) NULL,
)
```
Also, lets suppose that the `OrderType` column could be a variety of different cryptic string values: `"PC"` for pickup by customer, `"D"` for delivery, `"PT"` for pickup by third-party, And `"NONE"`,`""`, or `NULL` for an unknown order type. These abbreviations are rather unclear, and let's say you don't want to replicate this ambiguity in your data model class. What do you do?

Fear not! The `StringToEnumMappingRuleAttribute` is here. When you define your data model class, simply define the mapping rules you would like for each string variant:
```csharp
public class CustomerOrder
{
	[StringToEnumVariantMappingRule("PC", PickupByCustomer)]
	[StringToEnumVariantMappingRule("D", Delivery)]
	[StringToEnumVariantMappingRule("PT", PickupByThirdParty)]
	[StringToEnumVariantMappingRule("NONE", Unknown)]
	[StringToEnumVariantMappingRule("", Unknown)]
	public enum FulfillmentTypes
	{
		Unknown,
		PickupByCustomer,
		Delivery,
		PickupByThirdParty
	}

	[UniqueId]
	public Guid OrderId { get; set; }
	[DbPropertyName("OrderType")]
	public FulfillmentTypes FulfillmentType { get; set; }
}
```
We even could use `FulfillmentType` as the name of our property and just tell Atoms to map it to our `OrderType` column. As far as this example goes, the solution is as simple as that. No extra boilerplate or additional code to implement custom mapping rules. Just add your `StringToEnumMappingRuleAttribute`s directly above the definition of your enumeration. Now every time Atoms sees one of those cryptic string values it knows how to resolve it. Conversely, when Atoms needs to write the enumeration value to the database, it is able to write the appropriate string value.

One important thing to note when using mapping rules is that Atoms will use the very first mapping rule that matches, starting from top to bottom. So, if you have multiple rules for either the enum variant or the string variant, it will always use the first one. In this example, when we write to the database, Atoms will always map `FulfillmentTypes.Unknown` to `"NONE"` and never to `""` because it always uses the first matched rule. However, we may still want the `[StringToEnumVariantMappingRule("", Unknown)]` rule if we are reading from the database and the value happens to be `""`. Usually, it is best to have a single mapping rule for each string variant and enum variant, as it reduces complexity and the potential for unpredictable behavior. If `""` and `"NONE"` are not interchangeable and mean different things, then they should have separate mapping rules to separate enum variants. As stated before, `NULL` is always mapped to the first enum variant, which in this case is `FulfillmentTypes.Unknown`.
## Using nullable properties
If a data model class contains nullable public properties, they can be used by Atoms in the same way as any other property. Consider this table with a bunch of nullable columns:
```sql
CREATE TABLE CustomerAddresses(
	Phone VARCHAR(20) PRIMARY KEY,
	Unit INT NULL,
	StreetNumber INT NULL,
	Street NVARCHAR(100) NULL,
	PostalCode VARCHAR(20) NULL,
	City NVARCHAR(50) NULL,
	Province NVARCHAR(50) NULL,
	Country NVARCHAR(50) NULL
)
```
The corresponding data model class would be:
```csharp
[DbEntityName("CustomerAddresses")]
public class CustomerAddress
{
	[UniqueId]
	public string Phone { get; set; }
	public int? Unit { get; set; }
	public string? StreetNumber { get; set; }
	public string? Street { get; set; }
	public string? PostalCode { get; set; }
	public string? City { get; set; }
	public string? Province { get; set; }
	public string? Country { get; set; }
}
```
See, not surprising at all.
## String property max length constraints
Sometimes you may want to prevent unexpected string truncations for a database property by enforcing a maximum length. This can be accomplished by utilizing the `MaxLengthAttribute`, found in the `System.ComponentModel.DataAnnotations` namespace. Recall our `BlogPosts` table from earlier:
```sql
CREATE TABLE BlogPosts(
	PostId BIGINT NOT NULL,
	Genre NVARCHAR(20) NOT NULL,
	Title NVARCHAR(255) NOT NULL,
	Content NVARCHAR(MAX) NOT NULL,
	CONSTRAINT PK_BlogPosts PRIMARY KEY (PostId, Genre)
);
```
The `MaxLengthAttribute` can be added to the `Title` property like so:
```csharp
ï»¿using CalebBender.Atoms.DataAttributes;
using System.Collections.Generic;

public class BlogPost
{
	public enum BlogPostGenre
	{
		Horror,
		Thriller,
		Scifi,
		Fantasy
	}

	[UniqueId]
	public long PostId { get; set; }
	[UniqueId]
	public BlogPostGenre Genre { get; set; }
	[MaxLength(255)]
	public string Title { get; set; } = "";
	public string Content { get; set; } = "";
	public List<BlogComment>? BlogComments { get; set; }
}
```
Whenever Atoms writes the `Title` property or reads into the `Title` property, it will validate that the length of the string value does not exceed the constraint set by the `MaxLengthAttribute`. If the length does exceed this constraint, whether on a read or a write, Atoms will throw a `StringPropertyValueExceedsMaxLengthException`.
## Conclusion
In this section, you learned how to use the various data attributes that Atoms offers to flexibly configure your data model classes based on your specific needs. All a data model class needs to be used with an `IAtomicRepository` implementation is for at least one of its properties to be annotated with `UniqueIdAttribute`. However, in practice, you may find yourself needing to utilize the other attributes discussed here to flexibly configure your data model class the way you need it.